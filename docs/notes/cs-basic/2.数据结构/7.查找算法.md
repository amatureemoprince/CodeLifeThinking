---
title: 查找算法
createTime: 2025/05/16 21:44:59
permalink: /cs-basic/ds/search-algo/
icon: 'bx:search-alt'
---

> [!NOTE]
> 为了方便算法代码的书写，以下所有代码都是以int类型举例，重要的是算法的思想和性质。


## **什么是查找**

> 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找。

查找的结果只能有两种，分别为**查找成功**和**查找失败**，前者表示在查找表中寻找到了满足条件的元素，后者表示没有在查找表中寻找到满足条件的元素。
这里出现的**查找表**是用于查找的数据集合，其由同一类型的元素组成。

查找表有两种分类分别为：

- 静态查找表：对查找表只有查找操作，不存在修改元素的操作
- 动态查找表：对查找表有动态地插入和删除

静态查找容易理解，只存在查找操作而已，常见的**静态查找算法**有：折半查找、顺序查找、散列查找；动态查找值得说明一下，随着时间的流逝，数据集合中的数据会改变，
因为动态查找提供了除查找操作外的插入、删除操作，为了保持查找的高效性，常见的**动态查找算法**有：二叉排序树的查找、散列查找。

我们查找是根据**关键字**来进行查找的，那什么是关键字呢？就是用于查找的“标志”，其必然是**唯一**的，比如要以学生的学号将班上的学生进行排序，这里的学号就是关键字。

评判查找算法效率的重要指标是什么，我们怎样知道该查找算法好不好呢？这个指标就是**平均查找长度(ASL)**。顾名思义，就是查找到目标元素需要查找的平均次数。

::: info 注意
比较次数通常指的是**数据元素与目标值进行比较的次数**。
:::

$$ASL=\sum_{i=1}^nP_iC_i$$

**$P_i$是查找元素i的概率，$C_i$是查找元素i的比较次数，ASL是一个查找算法不能不谈的重要性质**。

## **顺序查找和折半查找**

这两个算法是最“耿直”的查找算法了，十分易懂和直接。

### **顺序查找**

---

顺序查找，显然说的是从一端到另一端依次查找，只要有目标元素就查找成功了，故顺序表和链表都可以使用该算法。

但是该线性表中的元素可能是有序的，也有可能是无序的，这两者的ASL是不同的，接下来一一说明。

==一般线性表的顺序查找==

为什么说是一般呢，这是因为不论是有序和无序都可以使用这个算法，但一般是给无序线性表使用的，因为有序线性表有自己更优秀的算法！

::: demo-wrapper no-padding title="一般线性表的顺序查找算法"
```c
int normal_search(int arr[], int len, int goal){
    for (int i = 0; i < len; i++) {
        if (arr[i] == goal) {
            return i;
        }
    }
    return -1;
}
```
:::

在这里还可以进行优化，使用**哨兵模式**，可以将内部的if判断条件全部省去！

原理是将目标元素放在线性表索引为0的位置上，然后从最后一个元素向前遍历，通过在for循环中的判断`arr[i]!=goal`（和上述的`i < len`一样的原理，
在for循环中`i++`一次就会判断是否还小于len），遍历的元素是否为目标元素，其一定能在arr中遍历到goal，最后返回对应的索引，不过线性表中不存在时返回的是0。

---

对于一般线性表顺序查找的ASL分析，假设有n个元素，且每个元素的查找概率相同：

$$ASL_{查找成功}=\sum_{i=0}^{n-1}\frac{1}{n}(i+1)=\frac{n+1}{2}$$

$$ASL_{查找失败}=n$$

由上述的ASL表达式可知，ASL与n呈线性相关，在n很大时，顺序查找的效率很低，但其对元素的存储和有序性没有任何要求。需要注意的是**链表只能进行顺序查找**！

==有序线性表的顺序查找==

不难想到，如果线性表中的元素有序的话，在查找失败时就可直接返回，后续剩余元素的比较都不用进行，降低了查找失败的ASL。

什么时候是失败呢？如果线性表关键字按从小到大排序，查找值为`goal`，若`i`位置元素小于`goal`，且`i+1`位置大于`goal`，则失败了。因为`i+1`位置上的元素都大于`goal`了，此后的元素必定也大于`goal`。

::: demo-wrapper no-padding title="有序线性表的顺序查找算法"
```c
int order_search_linear(int arr[], int len, int goal) {
    for (int i = 0; i < len; i++) {
        if (arr[i] == goal) {
            return i;
        } else if (arr[i] > goal) {
            return -1;
        }
    }
    return -1;
}
```
:::

每次判断都有三种可能，等于`goal`，大于`goal`，小于`goal`，等于的话就是查找成功，否则继续判断，这样可以将其抽象为一颗**二叉树**，该二叉树称为**判定树**。

![有序线性表查找的判定树](https://raw.githubusercontent.com/amatureemoprince/java-cofe-pictures/master/1743515983653-08346e79-982b-42d5-8eea-1ecca15f956b.jpeg)

矩形结点是**虚拟**的，也可以称为**失败结点**！

---

可知有序的线性表对应的查找成功ASL与一般的类似，不成功ASL更好一些：

$$ASL_{查找不成功}=\frac{1+2+3+...+n+n}{n+1}=\frac{n}{2} + \frac{n}{n+1}$$

### **折半查找**
---

### **分块查找**
---

## **树形查找**

为什么会出现**树形查找**呢？

### **二叉排序树（BST）**
---

### **平衡二叉树（AVL）**
---

### **红黑树（RBT）**
---

## **B树和B+树**

### **B树及其基本操作**
---

### **B+树及其基本操作**
---

## **散列表**

### **散列表的基本概念**
---

### **散列函数的构造方法**
---

### **处理冲突的方法**
---

### **散列查找及性能分析的应用**
---
---
title: 查找算法
createTime: 2025/05/16 21:44:59
permalink: /cs-basic/ds/search-algo/
icon: 'bx:search-alt'
---

> [!NOTE]
> 为了方便算法代码的书写，以下所有代码都是以int类型举例，重要的是算法的思想和性质。


## **什么是查找**

> 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找。

查找的结果只能有两种，分别为**查找成功**和**查找失败**，前者表示在查找表中寻找到了满足条件的元素，后者表示没有在查找表中寻找到满足条件的元素。
这里出现的**查找表**是用于查找的数据集合，其由同一类型的元素组成。

查找表有两种分类分别为：

- 静态查找表：对查找表只有查找操作，不存在修改元素的操作
- 动态查找表：对查找表有动态地插入和删除

静态查找容易理解，只存在查找操作而已，常见的**静态查找算法**有：折半查找、顺序查找、散列查找；动态查找值得说明一下，随着时间的流逝，数据集合中的数据会改变，
因为动态查找提供了除查找操作外的插入、删除操作，为了保持查找的高效性，常见的**动态查找算法**有：二叉排序树的查找、散列查找。

我们查找是根据**关键字**来进行查找的，那什么是关键字呢？就是用于查找的“标志”，其必然是**唯一**的，比如要以学生的学号将班上的学生进行排序，这里的学号就是关键字。

评判查找算法效率的重要指标是什么，我们怎样知道该查找算法好不好呢？这个指标就是**平均查找长度(ASL)**。顾名思义，就是查找到目标元素需要查找的平均次数。

::: info 注意
比较次数通常指的是**数据元素与目标值进行比较的次数**。
:::

$$ASL=\sum_{i=1}^nP_iC_i$$

**$P_i$是查找元素i的概率，$C_i$是查找元素i的比较次数，ASL是一个查找算法不能不谈的重要性质**。

## **顺序查找和折半查找**

这两个算法是最“耿直”的查找算法了，十分易懂和直接。

---

### **顺序查找**

顺序查找，显然说的是从一端到另一端依次查找，只要有目标元素就查找成功了，故顺序表和链表都可以使用该算法。

但是该线性表中的元素可能是有序的，也有可能是无序的，这两者的ASL是不同的，接下来一一说明。

==一般线性表的顺序查找==

为什么说是一般呢，这是因为不论是有序和无序都可以使用这个算法，但一般是给无序线性表使用的，因为有序线性表有自己更优秀的算法！

::: demo-wrapper no-padding title="一般线性表的顺序查找算法"
```c
int normal_search(int arr[], int len, int goal){
    for (int i = 0; i < len; i++) {
        if (arr[i] == goal) {
            return i;
        }
    }
    return -1;
}
```
:::

在这里还可以进行优化，使用**哨兵模式**，可以将内部的if判断条件全部省去！

原理是将目标元素放在线性表索引为0的位置上，然后从最后一个元素向前遍历，通过在for循环中的判断`arr[i]!=goal`（和上述的`i < len`一样的原理，
在for循环中`i++`一次就会判断是否还小于len），遍历的元素是否为目标元素，其一定能在arr中遍历到goal，最后返回对应的索引，不过线性表中不存在时返回的是0。

---

对于一般线性表顺序查找的ASL分析，假设有n个元素，且每个元素的查找概率相同：

$$ASL_{查找成功}=\sum_{i=0}^{n-1}\frac{1}{n}(i+1)=\frac{n+1}{2}$$

$$ASL_{查找失败}=n$$

由上述的ASL表达式可知，ASL与n呈线性相关，在n很大时，顺序查找的效率很低，但其对元素的存储和有序性没有任何要求。需要注意的是**链表只能进行顺序查找**！

==有序线性表的顺序查找==

不难想到，如果线性表中的元素有序的话，在查找失败时就可直接返回，后续剩余元素的比较都不用进行，降低了查找失败的ASL。

什么时候是失败呢？如果线性表关键字按从小到大排序，查找值为`goal`，若`i`位置元素小于`goal`，且`i+1`位置大于`goal`，则失败了。因为`i+1`位置上的元素都大于`goal`了，此后的元素必定也大于`goal`。

::: demo-wrapper no-padding title="有序线性表的顺序查找算法"
```c
int order_search_linear(int arr[], int len, int goal) {
    for (int i = 0; i < len; i++) {
        if (arr[i] == goal) {
            return i;
        } else if (arr[i] > goal) {
            return -1;
        }
    }
    return -1;
}
```
:::

每次判断都有三种可能，等于`goal`，大于`goal`，小于`goal`，等于的话就是查找成功，否则继续判断，这样可以将其抽象为一颗**二叉树**，该二叉树称为**判定树**。

![有序线性表查找的判定树](https://raw.githubusercontent.com/amatureemoprince/java-cofe-pictures/master/1743515983653-08346e79-982b-42d5-8eea-1ecca15f956b.jpeg)

矩形结点是**虚拟**的，也可以称为**失败结点**！

---

可知有序的线性表对应的查找成功ASL与一般的类似，不成功ASL更好一些：

$$ASL_{查找成功}=\frac{n+1}{2}$$

$$ASL_{查找不成功}=\frac{1+2+3+...+n+n}{n+1}=\frac{n}{2} + \frac{n}{n+1}$$

---

### **折半查找**

折半查找需要利用**有序**和**随机存取**特性，故只能用于**顺序存储结构**的线性表！

通过不断缩小目的元素所在的区间，直到找到或达到结束条件为止。比如从1-5中查找2，首先对比1-5中间的元素，显然3大于2，故2只能在1-3之间，依次类推从而找到2。

::: demo-wrapper no-padding title="折半查找算法"
```c
int binary_search(int arr[], int len, int goal){
    int low = 0;
    int high = len - 1;
    int mid;
    while(low <= high){
        mid = (high - low) / 2 + low;
        if(arr[mid] == goal){
            return mid;
        }
        else if (arr[mid] > goal){
            high = mid - 1;
        }
        else if (arr[mid] < goal){
            low = low + 1;
        }
    }
    return -1;
}
```
:::

每次比较都是比较的区间中间元素，故可以将折半查找的判定树抽象为一颗**平衡二叉树**，任意一个结点的子树高度相差不会超过1。

![折半查找判定树](https://raw.githubusercontent.com/amatureemoprince/java-cofe-pictures/master/查找树.png)

---

因为整体呈树形，其查找的时间复杂度显然为$O(log_2\,n)$

其对应的ASL为：

$$ASL_{查找成功}=\frac{1}{n}(1×1+2×2+...+h×2^{h-1})=\frac{n+1}{n}log_2(n+1)-1\approx log_2(n+1)-1$$

查找失败时的ASL根据之前比较的次数之和再除以整体的失败结点个数，上图的计算失败ASL如下：

$$ASL_{查找失败}=\frac{2×1+3×6}{7}=\frac{20}{7}$$

要查找到(11,14)失败结点，首先得比较上面的16、11、14，故比较次数为3，同一层的失败结点有6个，故为3×6，前面的2×1类似！

---

### **分块查找**

有没有办法将上面的算法综合一下呢？答案是有的，也就是**分块算法**。

通过一个索引数据结构快速找到对应区间，再从区间中查找目标元素，这就是该算法的基本思想。其和查字典的思想类似，先定位，再查找。

因为查找表中的元素被分为多个区间，且可以用区间内最大元素构造索引表，故区间之间元素需要有序（前一个区间内的最大值小于后一个区间的最小值），区间内元素无所谓。

用区间内最大元素构成索引表，若要查找的元素小于索引表中元素时，就从查找表对应的索引处开始查找元素。

![分块查找示意图](https://raw.githubusercontent.com/amatureemoprince/java-cofe-pictures/master/查找算法.png)

如：要查找上图13元素，先从索引表中确定13小于16，其索引值为3，所以从查找表索引3开始查找，找到13结束。

---

显然，查找算法的ASL为查找索引表的ASL加上查找查找表的ASL。设：长度为n的查找表均匀分为b块，每块有s个记录，在等概率的条件下，在块内和索引表中都采用顺序查找，则：

$$ASL_{查找成功}=\frac{s+1}{2} + \frac{b+1}{2}$$

$$ASL_{查找失败}=\frac{b}{2}+s$$

在查找成功的情况下，若$s=\sqrt n$，则平均查找成功长度有最小值$\sqrt n + 1$，通过基本不等式可轻松得出。

虽然分块查找使用额外的存储空间存储索引表，查找索引表也增加了一定开销，但这样带来的提升也是不小的，更普遍的情况是带来性能的提升大于开销。这也是环绕计算机的一个核心优化手段——**空间换时间**！

因为需要快速定位到查找表中的位置，所以需要**随机存取**特性，故此算法只适用于**顺序存储结构**。

## **树形查找**

为什么会出现**树形查找**呢？我们知道保持一颗优秀的二叉树可以使查找效率很高，因为此时无论是插入、查找、删除，其时间复杂度都为$O(log_2n)$。

这里引入的树形查找就是为了构造并保持这种优秀的二叉树结构！

---

### **二叉排序树（BST）**

> 定义：是一颗空树，或者满足下列性质的二叉树：
> - 若左子树非空，则左子树上所有结点的值均小于根结点的值
> - 若右子树非空，则右子树上所有结点的值均大于根结点的值
> - 左右子树也分别为一颗二叉树

意思就是**左小右大**，根据这个性质可知根结点为中间值，且用中序遍历二叉排序树可以得到一个递增的有序序列。

### **平衡二叉树（AVL）**
---

### **红黑树（RBT）**
---

## **B树和B+树**

### **B树及其基本操作**
---

### **B+树及其基本操作**
---

## **散列表**

### **散列表的基本概念**
---

### **散列函数的构造方法**
---

### **处理冲突的方法**
---

### **散列查找及性能分析的应用**
---
---
title: 数据在计算机中的表示方式
createTime: 2025/05/16 21:55:33
permalink: /cs-basic/principle/data-performance/
icon: 'carbon:data-share'
---

## **运算方法和运算电路**

计算机的一个核心功能就是**运算**，有没有想过内部的运算逻辑是怎样的呢？先从大局认识一下吧。

其中最核心的就是运算器，其由算术逻辑单元（ALU）、移位器、状态寄存器（PSW）、通用寄存器等部件构成，可以提供**四则运算**、**移位和求补操作**、**逻辑运算**等功能。



---

### **基本运算部件**

---

### **定点数的移位运算**

---

### **定点数的加减运算**

---

这里主要讨论**补码**和**原码**，其中**补码**又是最重要的！计算机中数值的表达和计算通常采用补码。

### **定点数的乘除运算**

## **浮点数的表示与运算**

在计算机中不光有整数，更常见的是**浮点数**。所谓“浮点”，就是小数点的位置是可以上下浮动。

---

### **浮点数的表示**

浮点数的表示和小学学过的科学计数法类似，其包含三个显示的数值和一个隐含的数值，显示的分别为**符号位**、**阶码**、**尾数**；隐含的是**基数**。

常见的是短浮点数格式：1位符号位（0正1负）+8位阶码（补码表示）+23位尾数（原码表示）。

---

### **浮点数的加减运算**

---

### **数据的大小端和对齐方式**

数据在计算机中的存放方式有大端和小端之分，但这只是种存储数据的方式罢了，没有什么特殊含义。

**大端方式**是将数据的低位部分存储到主存高位地址；**小端方式**是将数据的低位部分存储到主存低位地址。

举个例子：有个变量i地址为0800H，字节01234567H，按字节编址。显然i的最低位部分为67H，最高位部分为01H，若以小端方式存储，则67H存在主存地址0800H，45H存在主存地址0801H，以此类推。

计算机一次访存可以读取一个存储字的数据，若一个数据存储在两个存储字中，则需要两次访存，这样系统效率就被拖低了，为了防止这种情况的产生，将数据按**边界对齐**方式存储，换句话说，就是要让存储的数据整体放在一个存储字中，这样一次访存就可以取得目标数据，提高了系统效率。

为了实现这样的效果，在存储数据时可能会“浪费”部分内存用于填充空白字节，但往往这种“浪费”是值得的。

现代计算机都是按字节编址的，假设存储字长为32位，则一个存储字可以存放4字节，现在要在内存中存储“字节1、字节2、字节3、半字1、字1”，应该怎样存放呢？

因为要将数据整体存放在一个存储字中，所以字节1到字节3都可以存放在一个存储字中，由于存储字长为32位，还剩下1个字节没用，但紧接着要存储半字1，显然一个字节存不下去了，所以只能将半字1存储到下一个存储字中，同理，字1也得存储到下一个存储字中，每个存储字没有存储数据的部分填充空白字节。

![例子示意图](https://raw.githubusercontent.com/amatureemoprince/java-cofe-pictures/master/边界对齐.png)

对于边界对齐，在C语言的结构体中也有应用，主要是掌握住**结构体内每个成员按类型字节数大小对齐**和**结构体占用字节数为结构体内最大类型字节的倍数**。

::: demo-wrapper no-padding title="两个结构体"
```c
struct A{
	int a;
	char b;
	short c;
}

struct B{
	char b;
	int a;
	short c;
}
```
:::

仍保持存储字长为32位，对于`A`结构体而言，`a`会占用一个存储字，`b`和`c`共占一个存储字，所以`sizeof(A)=8`；对于`B`结构体同理可得应占10字节，但是要保证`B`结构体字节数为`sizeof(int)=4`的倍数，所以分配12字节，也就是`sizeof(B)=12`。

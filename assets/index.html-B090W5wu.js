import{_ as a,c as t,b as o,o as r}from"./app-B_u-pbfJ.js";const c={};function s(n,e){return r(),t("div",null,e[0]||(e[0]=[o('<h2 id="文件存储空间管理" tabindex="-1"><a class="header-anchor" href="#文件存储空间管理"><span>文件存储空间管理</span></a></h2><h3 id="_1、空闲表法" tabindex="-1"><a class="header-anchor" href="#_1、空闲表法"><span>1、空闲表法</span></a></h3><hr><h3 id="_2、空闲链表法" tabindex="-1"><a class="header-anchor" href="#_2、空闲链表法"><span>2、空闲链表法</span></a></h3><hr><h3 id="_3、位示图法" tabindex="-1"><a class="header-anchor" href="#_3、位示图法"><span>3、位示图法</span></a></h3><hr><h3 id="_4、成组链表法" tabindex="-1"><a class="header-anchor" href="#_4、成组链表法"><span><strong>4、成组链表法</strong></span></a></h3><p>上面3种方式都不适合用于<strong>大文件系统</strong>，会导致时间开销很大，所以引出<strong>成组链表法</strong>！</p><p>空闲链表法中的空闲盘区链是将相邻的盘块视为一个盘区，让一个盘区指向下一个盘区，但是如果每个盘区中只有 一个盘块，也会导致该链表很长，那有没有什么办法让不相邻的盘块也能构成一个“区”进行链接呢？</p><p>当然是有的，这就是成组链表法的原理。</p><p>将空闲盘块分为若干组（这里成为组，但是和之前的区是一样的含义）</p>',12)]))}const d=a(c,[["render",s]]),h=JSON.parse('{"path":"/cs-basic/os/file-manager/","title":"文件管理","lang":"zh-CN","frontmatter":{"title":"文件管理","createTime":"2025/05/16 21:52:17","permalink":"/cs-basic/os/file-manager/","icon":"solar:file-broken","description":"文件存储空间管理 1、空闲表法 2、空闲链表法 3、位示图法 4、成组链表法 上面3种方式都不适合用于大文件系统，会导致时间开销很大，所以引出成组链表法！ 空闲链表法中的空闲盘区链是将相邻的盘块视为一个盘区，让一个盘区指向下一个盘区，但是如果每个盘区中只有 一个盘块，也会导致该链表很长，那有没有什么办法让不相邻的盘块也能构成一个“区”进行链接呢？ 当然...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"文件管理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-21T13:46:36.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://codelifethinking.com/CodeLifeThinking/cs-basic/os/file-manager/"}],["meta",{"property":"og:site_name","content":"代码・生 活・THINKING"}],["meta",{"property":"og:title","content":"文件管理"}],["meta",{"property":"og:description","content":"文件存储空间管理 1、空闲表法 2、空闲链表法 3、位示图法 4、成组链表法 上面3种方式都不适合用于大文件系统，会导致时间开销很大，所以引出成组链表法！ 空闲链表法中的空闲盘区链是将相邻的盘块视为一个盘区，让一个盘区指向下一个盘区，但是如果每个盘区中只有 一个盘块，也会导致该链表很长，那有没有什么办法让不相邻的盘块也能构成一个“区”进行链接呢？ 当然..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T13:46:36.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T13:46:36.000Z"}]]},"readingTime":{"minutes":0.72,"words":215},"git":{"updatedTime":1750513596000,"contributors":[{"name":"代码・生 活・THINKING","username":"","email":"2069057986@qq.com","commits":5,"avatar":"https://gravatar.com/avatar/83898b2cefe8f7adb7ee830803c5872dc86f22f59d8156ec42a2df135ea55c11?d=retro"}],"changelog":[{"hash":"19cb29640f99bb1e9c5cd24222d96b50e40462c7","time":1750513596000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"fix:the project add"},{"hash":"7b20b4ccb83e60cdceea377d27a4c922c305d7fa","time":1750505844000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"fix:git-balabala🚀"},{"hash":"516eb761cfe8dc5d3776005332a60256ed3f7ef4","time":1748157810000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"docs:os-成组链表法🚀"},{"hash":"b307c1c7489742814a7d1b281993d41917b04a1f","time":1748008113000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"docs:os-file-manager🚀"},{"hash":"162ad30c6e92c840de0ece0a6a67202658909427","time":1747409814000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"docs:408-sidebar"}]},"autoDesc":true,"filePathRelative":"notes/cs-basic/3.操作系统/4.文件管理.md","headers":[]}');export{d as comp,h as data};

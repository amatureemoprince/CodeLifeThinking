import{_ as e,c as r,b as s,o as n}from"./app-B_u-pbfJ.js";const t={};function o(h,a){return n(),r("div",null,a[0]||(a[0]=[s('<div class="hint-container info"><p class="hint-container-title">概述</p></div><h2 id="内存管理概念" tabindex="-1"><a class="header-anchor" href="#内存管理概念"><span><strong>内存管理概念</strong></span></a></h2><hr><h3 id="内存管理的基本原理和要求" tabindex="-1"><a class="header-anchor" href="#内存管理的基本原理和要求"><span><strong>内存管理的基本原理和要求</strong></span></a></h3><blockquote><p>内存管理：操作系统必须对内存空间进行合理的划分和有效的动态分配。</p></blockquote><p>内存管理的主要功能有：</p><ul><li>内存空间的分配和回收</li><li>地址转换</li><li>内存空间的扩充</li><li>内存共享</li><li>存储保护</li></ul><p>详细内容请继续往下看！</p><hr><h3 id="逻辑地址和物理地址" tabindex="-1"><a class="header-anchor" href="#逻辑地址和物理地址"><span><strong>逻辑地址和物理地址</strong></span></a></h3><p>简单来说，逻辑地址就是程序员使用的，是虚假的，便于理解的，而物理地址是真正在内存中的地址，需要OS将逻辑地址转化得到的， 上层程序员不需要知道，是透明的。</p><p>程序在经过编译后，每个模块都是从0开始编址的，这些地址称为<strong>逻辑地址</strong>，当链接程序将各个模块链接为 一个可执行的程序时，需要将各个模块中的逻辑地址转换为<strong>物理地址</strong>，这个过程称为<strong>地址重定位</strong>。</p><p>逻辑地址方便了编程人员，也是用户和编程人员只用关心的，因为转换工作OS会自动处理好，而物理地址是真实在内存中的地址，进程运行时 需要的指令和数据都得从内存对应的物理地址上去取得。</p><p>需要说明的是：OS通过内存管理部件（MMU）将进程使用的逻辑地址转换为物理地址。进程使用虚拟内存空间中的地址， OS在相关硬件的协助下，将它转换物理地址。逻辑地址通过<strong>页表</strong>映射到物理地址，页表由OS维护并被处理器使用。</p><hr><h3 id="程序的链接和装入" tabindex="-1"><a class="header-anchor" href="#程序的链接和装入"><span><strong>程序的链接和装入</strong></span></a></h3><p>将用户源程序变为可以在内存中执行的程序需要经过以下步骤：</p><ul><li>编译：用编译程序将用户源代码编译为若干个目标模块</li><li>链接：用链接程序将若干个目标模块和目标模块需要的库函数链接在一起，形成一个完整的装入模块</li><li>装入：将装入模块转入到内存运行</li></ul><p>比如编译运行C语言时，总会引用多个头文件，链接程序就会将我们引用的头文件和自己写的代码链接在一起。</p><p>在<strong>将目标模块链接时</strong>和<strong>将装入模块转入内存时</strong>，是有多种方式的。</p><p><mark>将目标目标模块链接时</mark></p><ol><li>静态链接：在程序运行前，就已将链接完成了，以后不会再分开。</li><li>动态链接：在装入时，边装入边链接，便于修改和更新，便于实现对目标模块的共享。</li><li>运行式动态链接：执行到哪个模块才链接哪个模块，凡是程序执行时没有用到的目标模块都不会链，可以加快程序的装入过程和节省内存空间。</li></ol><p><mark>将装入模块转入内存时</mark></p><ol><li>绝对装入：在编译时就知道了程序将放到内存中的哪个位置，程序中的逻辑地址和物理地址完全相同。</li><li>可重定位装入（静态重定位）：程序中使用的指令和数据的地址都是相对于起始地址而言的逻辑地址。可以选择装入内存中的位置，但是已装入就得全部装入，一旦装入就不能在内存中移动和申请内存空间了。</li><li>动态运行时装入（动态重定位）：这种方式可以让程序在内存中移动，装入程序将装入模块装入内存后，并不会立即将装入模块中的逻辑地址转换为物理地址，而是将这种转换推迟到程序真正需要运行时才进行。</li></ol><p>2和3都可以决定在内存中的位置，但是2是一次性全部装入，且装入内存后不可以移动，是固定的。3的实现需要<strong>一个重定位寄存器</strong>，在装入时，会将逻辑地址加上重定位寄存器中的值， 所以是可以在内存中不停的改变位置，是动态的，灵活的。</p><hr><h3 id="进程的内存映像" tabindex="-1"><a class="header-anchor" href="#进程的内存映像"><span><strong>进程的内存映像</strong></span></a></h3><p>程序被调入内存时，在内存中的资源组成了该进程的内存映像。</p><p>进程的内存映像包括：</p><ul><li>代码段</li><li>数据段</li><li>进程控制段</li><li>堆</li><li>栈</li></ul><hr><h3 id="内存保护" tabindex="-1"><a class="header-anchor" href="#内存保护"><span><strong>内存保护</strong></span></a></h3><p>在分配内存时，不能让OS受到用户进程的影响，也不能让用户进程受到另一个用户进程影响。换句话说，OS给进程分配了内存，该进程就只能访问这个内存空间，不能越界。</p><p>有两种保护方式，但是核心思想是一样的。</p><p><strong>第一种</strong>：设置<strong>上、下限寄存器</strong>，用于存放用户进程在内存中的上、下限地址，每当CPU要访问内存时，要通过上、下寄存器判断是否越界。</p><p><strong>第二种</strong>：设置 <strong>重定位寄存器（基址寄存器）</strong> 和 <strong>界地址寄存器（限长寄存器）</strong>，前者保存进程的起始内存地址，后者保存进程最大的逻辑地址。</p><p>加载重定位寄存器和界地址寄存器必须使用<strong>特权地址</strong>，所以<strong>只有OS才能加载和修改这两者</strong>。</p><hr><h3 id="内存共享" tabindex="-1"><a class="header-anchor" href="#内存共享"><span><strong>内存共享</strong></span></a></h3><hr><h3 id="内存分配与回收" tabindex="-1"><a class="header-anchor" href="#内存分配与回收"><span><strong>内存分配与回收</strong></span></a></h3><p>总体来说是从连续分配到离散分配，这样提高了内存利用率。</p><p>连续分配中有：单一连续分配、固定分区分配、动态分区分配。</p><p>离散分配中有：页式存储管理、段式存储管理、段页式存储管理。</p><p>离散分配可用于虚拟内存技术的实现！</p><hr><h3 id="连续分配管理方式" tabindex="-1"><a class="header-anchor" href="#连续分配管理方式"><span><strong>连续分配管理方式</strong></span></a></h3><hr><h3 id="基本分页存储管理" tabindex="-1"><a class="header-anchor" href="#基本分页存储管理"><span><strong>基本分页存储管理</strong></span></a></h3><hr><h3 id="基本分段存储管理" tabindex="-1"><a class="header-anchor" href="#基本分段存储管理"><span><strong>基本分段存储管理</strong></span></a></h3><hr><h3 id="段页式存储管理" tabindex="-1"><a class="header-anchor" href="#段页式存储管理"><span><strong>段页式存储管理</strong></span></a></h3><h2 id="虚拟内存管理" tabindex="-1"><a class="header-anchor" href="#虚拟内存管理"><span><strong>虚拟内存管理</strong></span></a></h2><h3 id="虚拟内存的基本概念" tabindex="-1"><a class="header-anchor" href="#虚拟内存的基本概念"><span><strong>虚拟内存的基本概念</strong></span></a></h3><hr><h3 id="请求分页管理方式" tabindex="-1"><a class="header-anchor" href="#请求分页管理方式"><span><strong>请求分页管理方式</strong></span></a></h3><hr><h3 id="页框分配" tabindex="-1"><a class="header-anchor" href="#页框分配"><span><strong>页框分配</strong></span></a></h3><hr><h3 id="页面置换算法" tabindex="-1"><a class="header-anchor" href="#页面置换算法"><span><strong>页面置换算法</strong></span></a></h3><hr><h4 id="最佳置换算法-opt" tabindex="-1"><a class="header-anchor" href="#最佳置换算法-opt"><span><strong>最佳置换算法（OPT）</strong></span></a></h4><hr><h4 id="先进先出置换算法-fifo" tabindex="-1"><a class="header-anchor" href="#先进先出置换算法-fifo"><span><strong>先进先出置换算法（FIFO）</strong></span></a></h4><hr><h4 id="最近最久未使用置换算法-lru" tabindex="-1"><a class="header-anchor" href="#最近最久未使用置换算法-lru"><span><strong>最近最久未使用置换算法（LRU）</strong></span></a></h4><hr><h4 id="时钟置换算法-clock" tabindex="-1"><a class="header-anchor" href="#时钟置换算法-clock"><span><strong>时钟置换算法（CLOCK）</strong></span></a></h4><hr><h3 id="抖动和工作集" tabindex="-1"><a class="header-anchor" href="#抖动和工作集"><span><strong>抖动和工作集</strong></span></a></h3><p>抖动是在页面置换过程中，刚刚把一个页面换入马上又要换出，换出后又要马上换入，这种频繁的页面调度行为。</p><p>其根本原因是：分配给进程的物理块太少了，不能满足进程正常运行的基本要求，导致频繁地换页。</p><p>出现抖动的后果是很严重的，会导致磁盘I/O操作大量增加，CPU时间都用去换页，真正工作用的时间很少，使得 CPU利用率大大降低。</p><hr><h3 id="虚拟存储器性能影响因素" tabindex="-1"><a class="header-anchor" href="#虚拟存储器性能影响因素"><span><strong>虚拟存储器性能影响因素</strong></span></a></h3>',76)]))}const c=e(t,[["render",o]]),p=JSON.parse('{"path":"/cs-basic/os/memory-manager/","title":"内存管理","lang":"zh-CN","frontmatter":{"title":"内存管理","createTime":"2025/05/16 21:52:00","permalink":"/cs-basic/os/memory-manager/","icon":"material-symbols:memory-outline","description":"概述 内存管理概念 内存管理的基本原理和要求 内存管理：操作系统必须对内存空间进行合理的划分和有效的动态分配。 内存管理的主要功能有： 内存空间的分配和回收 地址转换 内存空间的扩充 内存共享 存储保护 详细内容请继续往下看！ 逻辑地址和物理地址 简单来说，逻辑地址就是程序员使用的，是虚假的，便于理解的，而物理地址是真正在内存中的地址，需要OS将逻辑地...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存管理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-06-21T13:46:36.000Z\\",\\"author\\":[]}"],["meta",{"property":"og:url","content":"https://codelifethinking.com/CodeLifeThinking/cs-basic/os/memory-manager/"}],["meta",{"property":"og:site_name","content":"代码・生 活・THINKING"}],["meta",{"property":"og:title","content":"内存管理"}],["meta",{"property":"og:description","content":"概述 内存管理概念 内存管理的基本原理和要求 内存管理：操作系统必须对内存空间进行合理的划分和有效的动态分配。 内存管理的主要功能有： 内存空间的分配和回收 地址转换 内存空间的扩充 内存共享 存储保护 详细内容请继续往下看！ 逻辑地址和物理地址 简单来说，逻辑地址就是程序员使用的，是虚假的，便于理解的，而物理地址是真正在内存中的地址，需要OS将逻辑地..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-21T13:46:36.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-21T13:46:36.000Z"}]]},"readingTime":{"minutes":5.8,"words":1740},"git":{"updatedTime":1750513596000,"contributors":[{"name":"代码・生 活・THINKING","username":"","email":"2069057986@qq.com","commits":7,"avatar":"https://gravatar.com/avatar/83898b2cefe8f7adb7ee830803c5872dc86f22f59d8156ec42a2df135ea55c11?d=retro"}],"changelog":[{"hash":"19cb29640f99bb1e9c5cd24222d96b50e40462c7","time":1750513596000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"fix:the project add"},{"hash":"7b20b4ccb83e60cdceea377d27a4c922c305d7fa","time":1750505844000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"fix:git-balabala🚀"},{"hash":"a2de726b2da9c52ce85fc8f844b120ac97cb5e97","time":1748928466000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"docs:cs-os-内存管理🚀"},{"hash":"76624144d82ff21fa4bd05434f2c1f231c40ec1d","time":1748926153000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"docs:cs-os-内存管理🚀"},{"hash":"7380a1501a385cf0c9e8c9bd53d65c6ec8d15e23","time":1747922166000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"docs:os-memory-manager🚀"},{"hash":"51a0008b165f3bd9dcb4114dbce040f4346d656e","time":1747894359000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"docs:os-memory-manager🚀"},{"hash":"162ad30c6e92c840de0ece0a6a67202658909427","time":1747409814000,"email":"2069057986@qq.com","author":"代码・生 活・THINKING","message":"docs:408-sidebar"}]},"autoDesc":true,"filePathRelative":"notes/cs-basic/3.操作系统/3.内存管理.md","headers":[]}');export{c as comp,p as data};
